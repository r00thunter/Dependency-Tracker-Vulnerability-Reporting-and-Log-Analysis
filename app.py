import os
import re
from dotenv import load_dotenv
import requests
import pandas as pd
from flask import Flask, render_template, request, redirect, url_for, send_file, jsonify

app = Flask(__name__)

# Load environment variables from .env file
load_dotenv()

def fetch_project_details():
    url = "http://{{change_me}}/endpoint/api/v1/project/"
    api_key = os.getenv('API_KEY')
    headers = {
        'X-Api-Key': api_key
    }

    try:
        response = requests.get(url, headers=headers, verify=False)
        response.raise_for_status()  # Raise an exception for bad responses (4xx or 5xx)
        return response.json()
    except requests.exceptions.RequestException as e:
        print(f"Error fetching project details: {e}")
        return []

def fetch_vulnerabilities(project_id):
    api_key = os.getenv('API_KEY')
    if not api_key:
        raise ValueError("API_KEY environment variable not set.")

    url = f"http://{{change_me}}/endpoint/api/v1/finding/project/{project_id}"
    headers = {
        'X-Api-Key': api_key
    }

    try:
        response = requests.get(url, headers=headers, verify=False)  # Add verify=False to ignore SSL cert errors
        response.raise_for_status()  # Raise an error for bad responses (4xx or 5xx)
        data = response.json()
        return data
    except requests.exceptions.RequestException as e:
        raise ValueError(f"Error fetching data from API: {e}")

def create_excel_report(project_id, report_name):
    try:
        data = fetch_vulnerabilities(project_id)
        if not data:
            return None
        
        rows = []
        for item in data:
            component = item['component']
            vulnerability = item['vulnerability']

            # Check if 'Severity' contains 'UNASSIGNED'; if true, skip adding to rows
            if 'UNASSIGNED' in vulnerability['severity']:
                continue

            component_name = component['name']
            component_version = component['version']
            latest_version = component.get('latestVersion', 'N/A')  # Default to 'N/A' if 'latestVersion' is not available

            row = {
                'Component UUID': component['uuid'],
                'Component Name': component_name,
                'Component Version': component_version,
                'Latest Version': latest_version,
                'Vulnerability ID': vulnerability['vulnId'],
                'Severity': vulnerability['severity'],
                'Description': vulnerability['description']
            }
            rows.append(row)

        df = pd.DataFrame(rows)
        reports_folder = os.path.join(os.getcwd(), 'reports')
        if not os.path.exists(reports_folder):
            os.makedirs(reports_folder)

        excel_filename = f"{report_name}.xlsx"
        excel_path = os.path.join(reports_folder, excel_filename)
        df.to_excel(excel_path, index=False, engine='openpyxl',
                    columns=['Component UUID', 'Component Name', 'Component Version', 
                             'Latest Version', 'Vulnerability ID', 'Severity', 'Description'])
        print(f"Excel report saved as {excel_path}")
        return excel_filename  # Return just the filename
    except Exception as e:
        print(f"Error creating Excel report: {e}")
        return None

def parse_log_file(file_path):
    logs = []
    log_pattern = re.compile(
        r'(?P<Date>\d{4}-\d{2}-\d{2}) (?P<Time>\d{2}:\d{2}:\d{2},\d{3}) \[(?P<Type>[^\]]+)\] (?P<Level>[^\s]+) - (?P<Message>.+) / username: (?P<Username>[^\s]+) / IP Address: (?P<IP>[^\s]+)'
    )
    
    with open(file_path, 'r') as file:
        for line in file:
            match = log_pattern.match(line)
            if match:
                logs.append(match.groupdict())
    
    return logs


@app.route('/')
def index():
    # Fetch project details
    projects = fetch_project_details()
    return render_template('index.html', projects=projects)

@app.route('/reports', methods=['GET', 'POST'])
def reports():
    if request.method == 'POST':
        print("POST request received")
        project_id = request.form.get('project_id')
        report_name = request.form.get('report_name')
        print(f"project_id: {project_id}, report_name: {report_name}")

        # Call create_excel_report function
        excel_filename = create_excel_report(project_id, report_name)
        if excel_filename:
            return redirect(url_for('download', filename=excel_filename))
        else:
            return "Error generating report."

    # Fetch project details
    projects = fetch_project_details()
    return render_template('reports.html', projects=projects)

@app.route('/logs')
def logs():
    log_file_path = '/{{change_me}}/dependency-track-audit.log'
    logs = parse_log_file(log_file_path)
    return render_template('logs.html', logs=logs)

@app.route('/api/logs')
def get_logs():
    try:
        df = read_log_data()
        return jsonify(df.to_dict(orient='records'))
    except Exception as e:
        return jsonify({"error": str(e)})

@app.route('/download/<filename>')
def download(filename):
    try:
        reports_folder = os.path.join(os.getcwd(), 'reports')
        return send_file(os.path.join(reports_folder, filename), as_attachment=True)
    except Exception as e:
        return str(e)

def read_log_data():
    log_file_path = '/{{change_me}}/dependency-track-audit.log'
    log_data = parse_log_file(log_file_path)
    
    # Convert to DataFrame
    df = pd.DataFrame(log_data)
    
    return df

def get_top_n(data, n=10):
    """Get the top n items from the data dictionary."""
    return dict(Counter(data).most_common(n))

@app.route('/api/metrics')
def get_metrics():
    try:
        log_file_path = '/{{change_me}}/dependency-track-audit.log'
        logs = parse_log_file(log_file_path)

        usernames = {}
        successful_logins = {}
        unauthorized_attempts = {}
        ip_addresses = {}

        for log in logs:
            # Username count
            username = log.get('Username')
            if username:
                if username not in usernames:
                    usernames[username] = 0
                usernames[username] += 1

                # Successful login count
                message = log.get('Message', '')
                if 'Successful login' in message:
                    if username not in successful_logins:
                        successful_logins[username] = 0
                    successful_logins[username] += 1

                # Unauthorized login attempts count
                if 'Unauthorized login attempt' in message:
                    if username not in unauthorized_attempts:
                        unauthorized_attempts[username] = 0
                    unauthorized_attempts[username] += 1

            # IP address count
            ip_address = log.get('IP')
            if ip_address:
                if ip_address not in ip_addresses:
                    ip_addresses[ip_address] = 0
                ip_addresses[ip_address] += 1

        # Get top 10 usernames and IP addresses
        top_usernames = dict(sorted(usernames.items(), key=lambda x: x[1], reverse=True)[:10])
        top_ip_addresses = dict(sorted(ip_addresses.items(), key=lambda x: x[1], reverse=True)[:10])

        return jsonify({
            'usernames': top_usernames,
            'successfulLogins': successful_logins,
            'unauthorizedAttempts': unauthorized_attempts,
            'ipAddresses': top_ip_addresses
        })
    except Exception as e:
        return jsonify({"error": str(e)})


if __name__ == "__main__":
    app.run(debug=True)